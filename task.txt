Task Description
Build the page below using Beego and Vanilla Javascript l
Task Breakdown
1. Visit h5ps://thecatapi.com and implement same feature previewed
2. Use vanilla JS as you preferred for frontend interaction
3. Use beego for controller, template rendering
4. Use go channel for API calls (MUST)
5. Utilize beego conﬁg for API key and other conﬁguration
6. Write Unit tests for achieve 80% Code Coverage


***************************************
go install github.com/beego/bee/v2@latest

go test ./tests -v
go test -coverprofile coverage.out ./...
go tool cover -html coverage.out

// run the test files separately
go test -v ./tests/cat_controller_test.go
go test -v ./tests/routers_test.go


******************************************
func TestFetchBreedWithImages(t *testing.T) {
    setupMockConfig() // Ensure mock configuration is set

    ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path == "/v1/breeds/abys" {
            json.NewEncoder(w).Encode(mockBreed)
        } else if r.URL.Path == "/v1/images/search" {
            mockImages := []struct {
                URL string `json:"url"`
            }{
                {URL: "http://example.com/cat1.jpg"},
                {URL: "http://example.com/cat2.jpg"},
            }
            json.NewEncoder(w).Encode(mockImages)
        } else {
            t.Errorf("Unexpected request to path: %s", r.URL.Path)
        }
    }))
    defer ts.Close()

    // Override API endpoints
    oldBreedDetailsURL := fetchBreedDetailsURL
    oldBreedImagesURL := fetchBreedImagesURL
    fetchBreedDetailsURL = ts.URL
    fetchBreedImagesURL = ts.URL
    defer func() {
        fetchBreedDetailsURL = oldBreedDetailsURL
        fetchBreedImagesURL = oldBreedImagesURL
    }()

    r, _ := http.NewRequest("GET", "/cat/fetch_breeds?id=abys", nil)
    w := httptest.NewRecorder()

    ctx := context.NewContext()
    ctx.Reset(w, r)

    controller := &controllers.CatController{}
    controller.Init(ctx, "CatController", "CatController", nil)
    controller.Ctx.Input.SetParam("id", "abys")

    controller.FetchBreeds()

    // Check response
    if w.Code != http.StatusOK {
        t.Errorf("Expected status code %d, got %d", http.StatusOK, w.Code)
    }

    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    if err != nil {
        t.Errorf("Failed to unmarshal response: %v", err)
    }

    if response["BreedDetails"] == nil {
        t.Error("Expected BreedDetails in response")
    }
    if response["BreedImages"] == nil {
        t.Error("Expected BreedImages in response")
    }
}
***********************************
func TestShowFavoriteImages(t *testing.T) {
	// Mock response from the API
	mockResponse := `[{"id":1, "image_id":"img123", "created_at":"2024-12-25"}]`
	req, err := http.NewRequest("GET", "/cat/fav_pics", nil)
	if err != nil {
		t.Fatal(err)
	}

	// Mock the API call (this is a simple mock example)
	// In real test, you may use a mock package like github.com/stretchr/testify/mock to mock the http client
	req.Header.Set("x-api-key", "test_api_key")

	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(controllers.ShowFavoriteImages)
	handler.ServeHTTP(rr, req)

	// Check if the response is successful
	assert.Equal(t, rr.Code, http.StatusOK)

	// Check the response body for expected data
	var response []map[string]interface{}
	json.NewDecoder(rr.Body).Decode(&response)

	assert.Equal(t, len(response), 1)
	assert.Equal(t, response[0]["image_id"], "img123")
}

func TestShowFavoriteImages_APIError(t *testing.T) {
	// Simulate an API error
	req, err := http.NewRequest("GET", "/cat/fav_pics", nil)
	if err != nil {
		t.Fatal(err)
	}

	// Mock an API failure, for example, 401 Unauthorized
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(controllers.ShowFavoriteImages)
	handler.ServeHTTP(rr, req)

	// Check if the status is 500 Internal Server Error due to API failure
	assert.Equal(t, rr.Code, http.StatusInternalServerError)
	var response map[string]string
	json.NewDecoder(rr.Body).Decode(&response)
	assert.Contains(t, response["error"], "Failed to fetch")
}
*********************************************
func TestDeleteFavoriteImage(t *testing.T) {
	// Mock response from the API
	req, err := http.NewRequest("DELETE", "/cat/delete_fav/12345", nil)
	if err != nil {
		t.Fatal(err)
	}

	// Simulate the request to the controller
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(controllers.DeleteFavoriteImage)
	handler.ServeHTTP(rr, req)

	// Check if status code is 200 OK
	assert.Equal(t, rr.Code, http.StatusOK)
	var response map[string]string
	json.NewDecoder(rr.Body).Decode(&response)
	assert.Equal(t, response["message"], "Favorite deleted successfully!")
}

func TestDeleteFavoriteImage_NotFound(t *testing.T) {
	// Simulate a failure when deleting
	req, err := http.NewRequest("DELETE", "/cat/delete_fav/nonexistent_id", nil)
	if err != nil {
		t.Fatal(err)
	}

	// Simulate the request to the controller
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(controllers.DeleteFavoriteImage)
	handler.ServeHTTP(rr, req)

	// Check if status code is 400 or some error code
	assert.Equal(t, rr.Code, http.StatusOK)
	var response map[string]string
	json.NewDecoder(rr.Body).Decode(&response)
	assert.Equal(t, response["message"], "Failed to delete favorite.")
}
*******************************************************
*******************************************************
Add Favs Images: POST 
*******************************************************
*******************************************************
///////////////////////
/*
// FavoriteImage handles the favoriting action for a cat image
func (c *CatController) FavoriteImage() {
    // Get image ID from the form
    imageID := c.GetString("image_id")
    if imageID == "" {
        c.Ctx.Output.SetStatus(http.StatusBadRequest)
        c.Data["json"] = map[string]string{"error": "Missing image ID"}
        c.ServeJSON()
        return
    }

    // Create a channel to receive the result of the API call
    ch := make(chan error)

    // Call the function to favorite the image in a goroutine
    go favoriteImageToAPI(imageID, ch)

    // Wait for the result (blocking until the goroutine completes)
    err := <-ch
    if err != nil {
        // Handle the error if the API request failed
        c.Ctx.Output.SetStatus(http.StatusInternalServerError)
        c.Data["json"] = map[string]string{"error": err.Error()}
        c.ServeJSON()
        return
    }

    // Redirect to the same page after successful operation
    c.Redirect("/cat/vote", http.StatusFound)
}

// Fav pics fetch API
func favoriteImageToAPI(imageID string, ch chan error) {
    apiKey, err := web.AppConfig.String("catapi_key")
    if err != nil {
        ch <- fmt.Errorf("failed to read API key from config: %v", err)
        return
    }

    favEndpoint := "https://api.thecatapi.com/v1/favourites"
    favRequest := map[string]interface{}{
        "image_id": imageID,
    }

    reqBody, err := json.Marshal(favRequest)
    if err != nil {
        ch <- fmt.Errorf("failed to marshal favorite request: %v", err)
        return
    }

    req, err := http.NewRequest("POST", favEndpoint, bytes.NewBuffer(reqBody))
    if err != nil {
        ch <- fmt.Errorf("failed to create request: %v", err)
        return
    }

    req.Header.Set("x-api-key", apiKey)
    req.Header.Set("Content-Type", "application/json")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        ch <- fmt.Errorf("failed to send favorite request for image_id %s: %v", imageID, err)
        return
    }
    defer resp.Body.Close()

    // Log response for debugging
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        ch <- fmt.Errorf("failed to read API response for image_id %s: %v", imageID, err)
        return
    }

    if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusCreated {
       
        fmt.Printf("Image successfully favorited for image_id %s. Response: %s\n", imageID, string(body))
        ch <- nil // Indicate success
    } else {
        
        ch <- fmt.Errorf("failed to favorite image_id %s. Status: %d, Response: %s", imageID, resp.StatusCode, string(body))
    }
}
*/
